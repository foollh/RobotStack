from math import degrees as dg
import numpy as np
import cv2 as cv
import math
import random

# 这部分的代码输出与Matlab里边的rotm2euler一致
def rotationMatrixToEulerAngles(R) :
    
    sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])
    
    singular = sy < 1e-6

    if  not singular :
        x = math.atan2(R[2,1] , R[2,2])
        y = math.atan2(-R[2,0], sy)
        z = math.atan2(R[1,0], R[0,0])
    else :
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0

    return np.array([z, y, x])


def main():
    objectPoints = np.array([[0.0, 0.0, 0.05],
                            [5.684341886080802e-14, 0.0, 0.3330000042915344],
                            [0.14636273682117462, 1.8747523427009583e-06, 0.6130605936050415],
                            [0.21947982907295227, -1.3571232557296753e-05, 0.5748487710952759],
                            [0.611931562423706, -7.615238428115845e-05, 0.5904653668403625],
                            [0.6848069429397583, -8.558239642297849e-05, 0.6397926211357117],
                            [0.744784414768219, -0.00010089341958519071, 0.5511828064918518]])
    #  ((0.0, 0.0, 0.05), (0.0, 0.0, 0.0, 1.0))
    # ((5.684341886080802e-14, 0.0, 0.3330000042915344), (0.0, 0.0, 6.403482530004112e-06, 1.0))  0
    # ((0.14636273682117462, 1.8747523427009583e-06, 0.6130605936050415), (-2.519715781090781e-05, 0.23846618831157684, -9.017764386953786e-05, 0.971150815486908))   2
    # ((0.21947982907295227, -1.3571232557296753e-05, 0.5748487710952759), (-0.45526739954948425, -0.5410042405128479, 0.5411282777786255, -0.4552209675312042))  3
    # ((0.611931562423706, -7.615238428115845e-05, 0.5904653668403625), (4.5825898268958554e-05, 0.7651833295822144, -7.674595690332353e-05, 0.6438125371932983))   4
    # ((0.6848069429397583, -8.558239642297849e-05, 0.6397926211357117), (0.8844428062438965, 0.36307787895202637, 0.2711576521396637, 0.11139543354511261))    6
    # ((0.744784414768219, -0.00010089341958519071, 0.5511828064918518), (0.6781747341156006, 0.6739017367362976, 0.20788776874542236, 0.2066834568977356))    8
    imagePoints = np.array([[195.01098633, 361.38032227],
                        [202.0918335,  280.81653442],
                        [234.3260498,  217.77509766],
                        [253.41015625, 222.99292603],
                        [349.53227539, 222.52093506],
                        [367.4677002,  212.37879639],
                        [381.73764648, 231.85806885]])

    cameraMatrix = np.mat([[197.55827961, 0., 0.],
                            [0., 148.16870971, 0.],
                            [0., 0., 1.]])
    distCoeffs = np.mat([0,0,0,0,0])

    _, R, T = cv.solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs)
    print('所求结果:')
    print("旋转向量",R)
    print("旋转矩阵：", cv.Rodrigues(R)[0])
    print("欧拉角：\n", rotationMatrixToEulerAngles(cv.Rodrigues(R)[0]))
    print("平移向量",T)

if __name__ == "__main__":
    main()